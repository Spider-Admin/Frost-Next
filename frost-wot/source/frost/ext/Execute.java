/*
Execute.java / Frost
Copyright (C) 2006  Frost Project <jtcfrost.sourceforge.net>

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of
the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/
package frost.ext;

import java.io.*;
import java.util.Map;

public abstract class Execute
{

    private static final int BUFF_SIZE = 10240;

    public static ExecResult run_wait(
            final String[] cmd)
    {
        return run_wait(cmd, "UTF-8", true, null, null);
    }

    public static ExecResult run_wait(
            final String[] cmd,
            final String charSet)
    {
        return run_wait(cmd, charSet, true, null, null);
    }

    public static ExecResult run_wait(
            final String[] cmd,
            final String charSet,
            final boolean grabOutput)
    {
        return run_wait(cmd, charSet, grabOutput, null, null);
    }

    /**
     * start an external program, wait for it to finish, and (optionally) return its output.
     * NOTE: check ExecResult.error for non-null to know if the command executed or not.
     * if it failed to execute, such as "No such file or directory", then "error.getMessage()"
     * will give a nice, printable message about the reason. and if you're on Mac/Linux, you
     * may even want to check ExecResult.returnCode for 0 (success), to know if the app itself
     * exited in a successful state. but unless you know the expected code, it's best to avoid that.
     * @param {String[]} cmd - the command to execute; must be at least 1 element (the command),
     * with its (optional) arguments in the subsequent array entries
     * @param {String} charSet - the character set to use for interpreting output, such as "UTF-8"
     * @param {boolean} grabOutput - whether or not to grab the stdOut and stdErr strings; setting
     * this to false improves performance, and is recommended in case you don't need to analyze the
     * results. if false, you will only get the "returnCode" in your ExecResult.
     * @param {File} workingDirectory - if non-null, the program will use this as its working dir,
     * otherwise it uses Frost's current working directory (which is the dir that frost.jar is in).
     * @param {Map<String,String>} extraEnvironment - if non-null, the provided key/value pairs will
     * be injected into the environment of the program (replacing any existing instances of that key).
     * TIP: since the environment itself is always unordered, you can use a regular unordered HashMap.
     * @return - the result generated by the program. standard output and error output are captured,
     * but only if requested via grabOutput (otherwise those two ExecResult fields are null).
     */
    public static ExecResult run_wait(
            final String[] cmd,
            final String charSet,
            final boolean grabOutput,
            final File workingDirectory,
            final Map<String,String> extraEnvironment)
    {
        ExecResult result = new ExecResult();
        if( cmd == null || charSet == null ) { return result; }

        try {
            // construct the launch arguments and start the process
            final ProcessBuilder pb = new ProcessBuilder(cmd);
            if( workingDirectory != null ) {
                // set the working directory of the program
                pb.directory(workingDirectory);
            }
            if( extraEnvironment != null ) {
                // inject the extra environment variables (overwriting any clashes)
                final Map<String,String> env = pb.environment();
                for( Map.Entry<String,String> entry : extraEnvironment.entrySet() ) {
                    final String thisKey = entry.getKey();
                    final String thisValue = entry.getValue();

                    // remove clashing key if it already exists
                    if( env.containsKey(thisKey) ) {
                        env.remove(thisKey);
                    }

                    // inject the key and value into the processbuilder's environment map
                    env.put(thisKey, thisValue);
                }
            }
            final Process proc = pb.start();

            // get all of the I/O pipes, so that we can read from them, and so that they'll
            // be automatically closed when the process finishes. (if we don't grab and auto-close
            // all streams, then we'll get dangling file system pipes after the process)
            try (
                // NOTE: Java 7+ try-with-resources (autocloseable)
                final InputStream stdOut = proc.getInputStream(); // output from program
                final InputStream stdErr = proc.getErrorStream(); // errors from program
                final OutputStream stdIn = proc.getOutputStream(); // input to the program; not used by us
            ) {
                char[] cbuf = new char[BUFF_SIZE];

                // consume everything from the standard output stream
                // NOTE: it is *extremely* important that we consume it even if we don't want the result,
                // because otherwise the launched process may fill up its own output buffer and crash.
                if( grabOutput ) { result.stdOut = new StringBuilder(); }
                try (
                    final InputStreamReader inputStreamReader = new InputStreamReader(stdOut, charSet);
                    final BufferedReader reader = new BufferedReader(inputStreamReader);
                ) {
                    int count = 0;
                    while( true ) {
                        count = reader.read(cbuf, 0, BUFF_SIZE);
                        if( count == -1 ) { break; } // end of stream
                        if( grabOutput ) { result.stdOut.append(cbuf, 0, count); }
                    }
                }

                // consume everything from the standard error stream
                if( grabOutput ) { result.stdErr = new StringBuilder(); }
                try (
                    final InputStreamReader inputStreamReader = new InputStreamReader(stdErr, charSet);
                    final BufferedReader reader = new BufferedReader(inputStreamReader);
                ) {
                    int count = 0;
                    while( true ) {
                        count = reader.read(cbuf, 0, BUFF_SIZE);
                        if( count == -1 ) { break; } // end of stream
                        if( grabOutput ) { result.stdErr.append(cbuf, 0, count); }
                    }
                }

                // if the process is still alive (even though the streams above have been closed),
                // then just wait until it exits; this usually never waits for long
                proc.waitFor();

                // get the return value from the finished process
                result.returnCode = proc.exitValue();
            }
        } catch( Throwable t ) {
            // save the exception information to the result object
            result.error = t;
        }

        return result;
    }

    public static void run_async(
            final String[] cmd)
    {
        run_async(cmd, null, null);
    }

    /**
     * execute a program without waiting for it to finish, and discard its output
     *
     * WARNING: Java doesn't support "real" asynchronous process spawning, so each invocation spawns
     * a new thread which lives until the spawned process exits. So don't overuse this function!
     * It's a good idea to check if your executed command blocks for a long time (which would hog
     * a Frost thread for a long time), or if it exits quickly. For instance, running "xdg-open"
     * on Linux is non-blocking, since it instantly launches the real application and then exits itself.
     *
     * @param {String[]} cmd - the command to execute; must be at least 1 element (the command),
     * with its (optional) arguments in the subsequent array entries
     * @param {File} workingDirectory - if non-null, the program will use this as its working dir,
     * otherwise it uses Frost's current working directory (which is the dir that frost.jar is in).
     * @param {Map<String,String>} extraEnvironment - if non-null, the provided key/value pairs will
     * be injected into the environment of the program (replacing any existing instances of that key).
     */
    public static void run_async(
            final String[] cmd,
            final File workingDirectory,
            final Map<String,String> extraEnvironment)
    {
        if( cmd == null ) { return; }
        new Thread("run_async") {
            @Override
            public void run() {
                // spawn the process and wait for it to exit. false = all output is ignored.
                run_wait(cmd, "UTF-8", false, workingDirectory, extraEnvironment);
            }
        }.start();
    }
}
